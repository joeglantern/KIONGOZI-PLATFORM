import * as Sharing from 'expo-sharing';
import * as FileSystem from 'expo-file-system/legacy';
import { Alert } from 'react-native';

export type ExportFormat = 'text';
export type ExportScope = 'current' | 'all';

export interface Message {
  id: string;
  text: string;
  isUser: boolean;
  timestamp?: string;
  type?: string;
}

export interface Conversation {
  id: string;
  title?: string;
  messages: Message[];
  created_at?: string;
  updated_at?: string;
}

export interface ExportOptions {
  format: ExportFormat;
  scope: ExportScope;
  conversations: Conversation[];
  includeTimestamps?: boolean;
  includeMetadata?: boolean;
}

class ExportUtils {
  /**
   * Export conversations as plain text
   */
  async exportConversations(options: ExportOptions): Promise<boolean> {
    try {
      const { conversations } = options;

      if (conversations.length === 0) {
        Alert.alert('No Data', 'No conversations to export.');
        return false;
      }

      // Format as plain text
      const content = this.formatAsText(conversations, options);
      const filename = `kiongozi_conversations_${Date.now()}.txt`;

      // Write content to a temporary file using legacy API
      const fileUri = FileSystem.documentDirectory + filename;
      await FileSystem.writeAsStringAsync(fileUri, content);

      // Share the file
      if (await Sharing.isAvailableAsync()) {
        await Sharing.shareAsync(fileUri, {
          mimeType: 'text/plain',
          dialogTitle: 'Export Conversations',
        });
      } else {
        Alert.alert('Export Complete', `File saved as ${filename}`);
      }

      return true;
    } catch (error) {
      console.error('Export error:', error);
      Alert.alert('Export Failed', 'Could not export conversations. Please try again.');
      return false;
    }
  }

  /**
   * Format conversations as plain text
   */
  private formatAsText(conversations: Conversation[], options: ExportOptions): string {
    const { includeTimestamps = true, includeMetadata = true } = options;
    let content = '';

    if (includeMetadata) {
      content += 'Kiongozi Platform - Conversation Export\n';
      content += `Generated on: ${new Date().toLocaleString()}\n`;
      content += `Total Conversations: ${conversations.length}\n`;
      content += '=' .repeat(50) + '\n\n';
    }

    conversations.forEach((conversation, index) => {
      const title = conversation.title || `Conversation ${index + 1}`;
      content += `${title}\n`;
      content += '-'.repeat(title.length) + '\n';

      if (includeTimestamps && conversation.created_at) {
        content += `Created: ${new Date(conversation.created_at).toLocaleString()}\n`;
      }

      content += '\n';

      conversation.messages.forEach((message) => {
        // Skip welcome messages for cleaner export
        if (message.text.includes('Habari!') || message.text.includes('Welcome')) {
          return;
        }

        const sender = message.isUser ? 'You' : 'Kiongozi AI';
        const timestamp = includeTimestamps && message.timestamp
          ? ` [${new Date(message.timestamp).toLocaleString()}]`
          : '';

        content += `${sender}${timestamp}: ${message.text}\n\n`;
      });

      content += '\n' + '='.repeat(50) + '\n\n';
    });

    if (includeMetadata) {
      content += '\n---\nGenerated by Kiongozi Platform - Kenyan Civic Education AI\n';
    }

    return content;
  }


  /**
   * Get a summary of what will be exported
   */
  getExportSummary(conversations: Conversation[]): string {
    const totalMessages = conversations.reduce((sum, conv) => sum + conv.messages.length, 0);
    const dateRange = this.getDateRange(conversations);

    return `${conversations.length} conversation(s) with ${totalMessages} message(s)${dateRange ? ` from ${dateRange}` : ''}`;
  }

  /**
   * Get date range of conversations
   */
  private getDateRange(conversations: Conversation[]): string | null {
    const dates = conversations
      .map(conv => conv.created_at)
      .filter(Boolean)
      .map(date => new Date(date!))
      .sort((a, b) => a.getTime() - b.getTime());

    if (dates.length === 0) return null;

    const earliest = dates[0];
    const latest = dates[dates.length - 1];

    if (earliest.toDateString() === latest.toDateString()) {
      return earliest.toLocaleDateString();
    }

    return `${earliest.toLocaleDateString()} - ${latest.toLocaleDateString()}`;
  }
}

export const exportUtils = new ExportUtils();
export default exportUtils;